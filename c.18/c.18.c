#include <stdio.h>
#include <windows.h>
//Debug:调试版本，包含调试信息，并且不作任何优化，便于调试
//Release:发行版本


//strcpy：字符串拷贝
//void my_strcpy(char* dest, char* src)
//{
//	while (*src != '\0')
//	{
//		*dest = *src;
//		src++;
//		dest++;
//	}
//	*dest = *src;//当*src='\0'
//}
//int main()
//{
//	char arr1[] = "##################";
//	char arr2[] = "bit";
//	my_strcpy(arr1, arr2);//将arr2拷贝到arr1
//	printf("%s\n", arr1);
//	return 0;
//}

//void my_strcpy(char* dest, char* src)
//{
//	while (*src != '\0')
//	{
//		*dest = *src;
//		src++;
//		dest++;
//	}
//	*dest = *src;//当*src='\0'
//}
//int main()
//{
//	char arr1[] = "##################";
//	char arr2[] = "bit";
//	my_strcpy(arr1, arr2);//将arr2拷贝到arr1
//	printf("%s\n", arr1);
//	return 0;
//}

////assert的应用
//void my_strcpy2(char* dest, const char* src)
//{
//	char* ret = dest;
//	assert(dest != NULL);//断言
//	arrest(src != NULL);//断言
//	//把src指向的字符串拷贝到dest指向的空间，包含'\0'字符
//	while (*dest++ = *src++)//当src++='\0'时while(0)循环停止
//	{
//		;
//	}
//	return ret;
//}
//int main()
//{
//	char arr1[] = "#################";
//	char arr2[] = "bit";
//	my_strcpy2(arr1, arr2);
//	printf("%s\n", arr1);
//	return 0;
//}

//
//int main()
//{
//	const int num = 10;
//	int n = 100;
//	int* p = &num;
//	//const 放在指针变量的*左边时，修饰的是*p,也就是说：不能通过p来改变*p(num)的值
//	//const 放在指针变量的*右边时，修饰的是指针变量P本身，p不能被改变了
//	*p = 20;
//	p = &n;
//	printf("%d\n", num);
//	return 0;
//}

//数据在内存中的存储
//char           字符数据类型
//short          短整型
//int            整型
//long           长整型
//long long      更长的整型
//float          单精度浮点型
//double         双精度浮点型
//类型的意义
//1.使用这个类型开辟空间的大小（大小决定了使用范围）
//2.如何看待内存空间的视角

//unsign char    范围0-255
//sign char      范围-128-127


//构造类型
//数字类型
//结构体类型 struct
//枚举类型   enum
//联合类型   union


////指针类型
//int* pi;
//char* pc;
//float* pf;
//void* pv;
//空类型:void表示空类型（无类型），通常应用于函数的返回类型、函数的参数、指针类型



//符号数三种表示方法：原码、反码、补码

//有符号一般指的是整型

//无符号：原码、反码、补码都相同


//符号位用0表示“正”，用1表示“负”

//原码：直接将二进制按照正负的形式翻译成二进制

//反码：将原码的符号位不变，其他位依次按位取反就可以得到

//补码：反码+1

//正数的原码、反码、补码都相同

//整数：数据存放内存中其实存放的是补码

//存放的是补码原因：使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理（cpu只有加法器）
//此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路

//int main()
//{   
//	//正数
//	int a = 20;//4个字节-32bit
//	//0000 0000 0000 0000 0000 0000 0001 0100   -原码
//	//0000 0000 0000 0000 0000 0000 0001 0100   -反码
//	//0000 0000 0000 0000 0000 0000 0001 0100   -补码
//
//	//负数
//	int b = -10;
//	//1000 0000 0000 0000 0000 0000 0000 1010   -原码
//	//1111 1111 1111 1111 1111 1111 1111 0101   -反码
//	//1111 1111 1111 1111 1111 1111 1111 0110   -补码
//
//}
//整数在内存中存储的是补码


//大小端?????
//对字节讨论
//大端（存储）模式：数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
//小端（存储）模式：数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中；

//int main()
//{
//	int a = 20;
//	0000 0000 0000 0000 0000 0000 0001 0100
//}




//指针类型的意义
//1.指针类型决定了指针引用操作能访问几个字节：char*p;*p访问1个字节，int*p;*p访问4个字节
//2.指针类型决定了指针+1，-1，加的或者减的是几个字节；char*p;p+1,跳过一个字节，int*p;p+1,跳过一个整型-4个字节

//输出什么？
//char类型以%d输出时整型提升

//有符号的整型提升时补1

//无符号的整型提升时补0

//符号位1表示负数
//符号数0表示正数
//int mian()
//{
//	char a = -1;
//	// 1000 0001   原码
//	// 1111 1110   反码
//	// 1111 1111   补码
//	//负数整型提升高位补符号位1
//	///1111 1111 1111 1111 1111 1111 1111 1111  整型提升后
//	//char类型占1个字节，8个bit
//	signed char b = -1;
//	//1111 1111    补码
//	//1111 1111 1111 1111 1111 1111 1111 1111 整型提升后
//	unsigned char c = -1;
//	//1111 1111    补码
//	//0000 0000 0000 0000 0000 0000 1111 1111 整型提升后
//	printf("a=%d,b=%d,c=%d", a, b, c);//-1，-1，255
//	//%d打印的是整数，所以char类型要整型提升
//	return 0;
//}


//输出结果是什么

//补码：10000000  表示 -128
//int main()
//{
//	char a = -128;
//	//1000 0000 补码
//	//1111 1111 1111 1111 1111 1111 1000 0000 整型提升后
//	printf("%u\n", a);//4294967168
//	//char类型，所以要整型提升
//	//%d：打印十进制的有符号数字
//	//%u:打印十进制的无符号数字
//	//此时要打印的是无符号型的数字，所以原码、反码、补码都相同
//	return 0;
//}

//有符号的char的范围是：-128到127
//无符号的char的范围是：   0到255


//int main()
//{
//	char a = 128;
//	//char类型中没有128，此处相当于127+1
//	//在char中表示128
//	//127：0111 1111 因为127为正数所以原码、反码、补码相同
//	//  1：0000 0001 
//	//127+1：1000 0000 
//
//	//因为127+1，最高位为1所以整型提升高位补1：
//	//1111 1111 1111 1111 1111 1111 1000 0000
//	//整型提升后：
//	printf("%u\n", a);
//	return 0;
//}

//int main()
//{
//	int i = -20;
//	//10000000 00000000 00000000 00010100  原码
//	//11111111 11111111 11111111 11101011  反码
//	//11111111 11111111 11111111 11101100  补码
//	unsigned int j = 10;
//	//00000000 00000000 00000000 00001010  补码
//	//11111111 11111111 11111111 11110110  相加的结果：有符号的补码
//	//11111111 11111111 11111111 11110101  结果的反码
//	//10000000 00000000 00000000 00001010  结果的原码：-10
//	printf("%d\n", i + j);//-10
//	//输出的是原码
//	
//	//存储的是补码
//	
//	//计算的是补码
//	
//	//按照补码的形式进行运算，最后格式化成为有符号整数
//	return 0;
//}

//int mian()
//{
//	unsigned char i;//无符号char范围：0-255
//	for (i = 9; i >= 0; i--)//无符号char范围：0-255,所以i>=0恒成立，循环为死循环
//	{
//		printf("%u\n", i);
//		Sleep(100);
//	}
//	return 0;
//}

////输出结果是什么
//int main()
//{
//	char a[1000];//下标0-999，char范围-128到127
//	//遍历从-1，-2.........-128,127,126.....0，此处遇到字符串结束标志\0
//	//所以共有255个
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));//255
//	//计算字符串大小
//}

//unsigned char i = 0;//无符号char范围0到255，所以i超不过255，死循环
//int main()
//{
//	for(i=0;i<=255;i++)
//	{
//		printf("hello word\n");
//	}
//	return 0;
//}

